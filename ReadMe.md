# Тестовое задание Java: Citeck

Общие сведения:
-----------------
    Тестовое задание Java: Citeck 
    Автор: Oleg Ustsov
    Дата выполнения: 2020-08-05
    
Задание 1:
--------------------------------------
    Имеется массив чисел,
    получить список вида {число, количество вхождений числа в массив},
    список должен быть отсортирован по количеству вхождений, внутри по возрастания числа.

    Пакет: com.menggp.citecktets.task1
    Входной класс: ArrayIndexer

    План реализации:
    1. Подготовка начальных данных
        генерируем массив целых чисел заданного размера, в заданном диапазоне чисел, параметры в константах
            SIZE    - размер массива
            MIN     - минимальное значение элемента
            MAX     - максимальное значение элемента
    2. Индексация массива - т.е. подсчет вхождений каждого элемента в массив
        в итоге получаем список List<> элементов  тип {ключ, значение}, где
                ключ - элемент массива (исходного)
                значение - количество вхождений элемента
         для индексации будем использовать структуру HashMap<>
    3. Сортировка
            отсортируем полученный список:
                - по количеству вхождений - по убыванию
                - для равных значений количества, по значению числа - по возрастанию
            определим для элементов списка {ключ, значение} компаратор реализующий условие сравнения

Задание 2:
--------------------------------------
    Написать алгоритм проверки корректности регулярного выражения, которое включает [,],(,) 
    т.е., например ([][[]()]) - правильно, ([][]()]) – неправильно

    Пакет: com.menggp.citecktets.task2
    Входной класс: RegExpChecker

    План реализации:
    1. Уточнение условия:
        - в качестве условия корректности выражения примем ТОЛЬКО условие согласованности в нем скобок,
            прочие условия НЕ проверяем (# недопустимые символы, несогласованные операторы и т.д.)
        - положим что могут встречаться ТОЛЬКО следующие виды скобок: (), [], {}, <>
    2. Входные данные: зададим выражения в константах:
            REG_EXP_SAMPLE_1
            REG_EXP_SAMPLE_2
            REG_EXP_SAMPLE_3
    3. Разбор выражения и анализ согласованности скобок:
        - посимвольно читаем строку с выражением
        - в процессе разбора строки проверяем согласованность скобок с помощью стека:
            * если встречаем открывающую скобку - помещаем в стек
            * если встречаем закрывающую скобку - проверяем вершину стека:
                если скобка того же типа - извлекаем вершину
                иначе - выражение не верно
          возможны 2 варианты несогласованности:
            * открывающая скобка без закрывающей 
                - по окончанию разбора строки стек не пуст
            * несогласованная закрывающая скобка 
                - при разборке строки найдена несогласованная (с вершиной стека) скобка

Задание 3:
--------------------------------------
    Написать алгоритм, как в целом числе самый правый ноль превратить в единицу не используя циклы и рекурсию.

    Пакет: com.menggp.citecktets.task3
    Входной класс: RightZeroIncrement

    План реализации:
     1. Преобразуем число в строку
     2. Находим индекс крайнего правого 0
     3. Заменяем символ по полученному индексу на 1
     4. Преобразуем строку обратно в число


Задание 4:
--------------------------------------
    Имеется таблица с 1 полем, заполненная числами по порядку: {1,2,4,7,8,11..}.
    Написать SQL Запрос который делает выборку следующего вида (2 столбца): {{3,1},{5,2},...},
    Т.е. в первом поле идет число, с которого начинается пропуск, во втором количество пропущенных чисел

    Пакет: com.menggp.citecktets.task4
    Входной класс: NumExtractorSQL

    План реализации:
    1. Подготовка начальных данных:
        - Инициализируем БД - используем БД "h2" в режиме in-memory
        - Записываем в БД данные - значения от 1
    2. Извлечение данных из БД
        - извлекаем 2 списка:
            1. числа - после которых начинается пропуск
            2. числа - которыми заканчивается пропуск
        - на их основе получаем значения чисел:
            * число с которого начинается пропуск
            * количество пропущенных чисел






